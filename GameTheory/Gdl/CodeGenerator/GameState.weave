@model CompileResult
{{
    var types = model.ExpressionTypes;
    var roles = (RelationInfo)types[("ROLE", 1)];
    var roleEnum = (EnumType)roles.Arguments[0].ReturnType;

    var allTypes = new List<ExpressionType>();
    var allExpressions = new List<ExpressionInfo>();
    ExpressionTypeVisitor.Visit(types.Values, visitExpression: allExpressions.Add, visitType: allTypes.Add);
}}
using System;
using System.Collections.Generic;
using GameTheory;

{{each type in allTypes}}
    {{@RenderExpressionType type}}
{{/each}}
public class GameState : IGameState<Move>
{
    private IReadOnlyList<PlayerToken> players;
    private HashSet<string> state;

    public GameState()
    {
        this.players = new PlayerToken[{{= roleEnum.Objects.Count}}]
        {
            {{each p in roleEnum.Objects}}
                new PlayerToken(), // {{= p.Id}}
            {{/each}}
        };
    }

    {{each expr in allExpressions}}
        {{@RenderExpressionInfo expr}}
    {{/each}}
    /// <inheritdoc />
    public IReadOnlyList<PlayerToken> Players { get { return this.players; } }

    /// <inheritdoc />
    public IReadOnlyList<Move> GetAvailableMoves()
    {
        throw new NotImplementedException();
    }

    /// <inheritdoc />
    public IEnumerable<IWeighted<IGameState<Move>>> GetOutcomes(Move move)
    {
        yield return Weighted.Create(this.MakeMove(move), 1);
    }

    /// <inheritdoc />
    public IEnumerable<IGameState<Move>> GetView(PlayerToken playerToken, int maxStates)
    {
        yield return this;
    }

    /// <inheritdoc />
    public IReadOnlyCollection<PlayerToken> GetWinners()
    {
        throw new NotImplementedException();
    }

    /// <inheritdoc />
    public IGameState<Move> MakeMove(Move move)
    {
        throw new NotImplementedException();
    }

    /// <inheritdoc />
    public int CompareTo(IGameState<Move> other)
    {
        if (object.ReferenceEquals(other, this))
        {
            return 0;
        }

        var state = other as GameState;
        if (object.ReferenceEquals(state, null))
        {
            return 1;
        }

        throw new NotImplementedException();
    }
}

public class Move : IMove
{
    private string value;
    private PlayerToken playerToken;

    public Move(PlayerToken playerToken, string value)
    {
        this.playerToken = playerToken;
        this.value = value;
    }

    /// <inheritdoc />
    public bool IsDeterministic { get { return true; } }

    /// <inheritdoc />
    public PlayerToken PlayerToken { get { return this.playerToken; } }

    public string Value { get { return this.value; } }

    /// <inheritdoc />
    public IList<object> FormatTokens { get { return new object[] { this.value }; } }
}
