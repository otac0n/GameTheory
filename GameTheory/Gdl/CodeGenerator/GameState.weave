@model CompileResult
{{
    var relations = model.KnowledgeBase.Forms.OfType<ImplicitRelationalSentence>().ToLookup(r => r.Relation.Id);
    var players = relations["ROLE"].Select(r => r.Arguments.Single()).ToList();
    var inits = relations["INIT"].Select(r => r.Arguments.Single()).ToList();

    var types = model.ExpressionTypes.Values;
}}
using System;
using System.Collections.Generic;
using GameTheory;

public class GameState : IGameState<Move>
{
    private IReadOnlyList<PlayerToken> players;
    private HashSet<string> state;

    public GameState()
    {
        this.players = new PlayerToken[{{= players.Count}}]
        {
            {{each p in players}}
                new PlayerToken(), // {{= p}}
            {{/each}}
        };

        this.state = new HashSet<string>
        {
            {{each i in inits}}
                {{= ToLiteral(i)}},
            {{/each}}
        };
    }

    /// <inheritdoc />
    public IReadOnlyList<PlayerToken> Players { get { return this.players; } }

    /// <inheritdoc />
    public IReadOnlyList<Move> GetAvailableMoves()
    {
        throw new NotImplementedException();
    }

    /// <inheritdoc />
    public IEnumerable<IWeighted<IGameState<Move>>> GetOutcomes(Move move)
    {
        yield return Weighted.Create(this.MakeMove(move), 1);
    }

    /// <inheritdoc />
    public IEnumerable<IGameState<Move>> GetView(PlayerToken playerToken, int maxStates)
    {
        yield return this;
    }

    /// <inheritdoc />
    public IReadOnlyCollection<PlayerToken> GetWinners()
    {
        throw new NotImplementedException();
    }

    /// <inheritdoc />
    public IGameState<Move> MakeMove(Move move)
    {
        throw new NotImplementedException();
    }

    /// <inheritdoc />
    public int CompareTo(IGameState<Move> other)
    {
        if (object.ReferenceEquals(other, this))
        {
            return 0;
        }

        var state = other as GameState;
        if (object.ReferenceEquals(state, null))
        {
            return 1;
        }

        throw new NotImplementedException();
    }

    {{each type in types}}
        {{@RenderExpressionInfo type}}
    {{/each}}
}

public class Move : IMove
{
    private string value;
    private PlayerToken playerToken;

    public Move(PlayerToken playerToken, string value)
    {
        this.playerToken = playerToken;
        this.value = value;
    }

    /// <inheritdoc />
    public bool IsDeterministic { get { return true; } }

    /// <inheritdoc />
    public PlayerToken PlayerToken { get { return this.playerToken; } }

    public string Value { get { return this.value; } }

    /// <inheritdoc />
    public IList<object> FormatTokens { get { return new object[] { this.value }; } }
}
