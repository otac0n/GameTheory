;
; Atari Go with legal GDL, using Zavain Dar hack for Hex.
; Cells have a string label, changed when two strings are connected.
;  jm@univ-paris8.fr, march 2013
;
(role white)
(role black)

;; alternate play
(init (control black))
(<= (next (control white))  (true (control black)))
(<= (next (control black))  (true (control white)))
(<= (notcontrol white)  (true (control black)))
(<= (notcontrol black)  (true (control white)))

;; step counter used to label strings of stones
(init (step 1))
(<= (next (step ?n+1))  (true (step ?n)) (++ ?n ?n+1))

;; need to merge neighbour strings of the same color
(<= (relabel ?x)
    (role ?p)
    (does ?p (mark ?l ?c))	 ; new stone
    (neighbour ?l ?c ?lo ?co)	 ; with a neighbour
    (true (cell ?lo ?co ?p ?x))) ; of the same color

;; Transfer colors and labels
; new stone
(<= (next (cell ?l ?c ?p ?s)) (role ?p) (does ?p (mark ?l ?c)) (true (step ?s)))
; old stone
(<= (next (cell ?l ?c ?p ?x)) (true (cell ?l ?c ?p ?x)) (not (relabel ?x)))
(<= (next (cell ?l ?c ?p ?s)) (true (cell ?l ?c ?p ?x)) (relabel ?x) (true (step ?s)))

;; (at least) one liberty for the string with label ?x
(<= (lib ?x)
    (true (cell ?l ?c ?p ?x))
    (neighbour ?l ?c ?lo ?co)
    (empty ?lo ?co))

;; end of game: captures win, suicides loose
(<= terminal (true (cell ?l ?c ?p ?n)) (not (lib ?n)))
(<= captured
    (true (control ?p))
    (true (cell ?l ?c ?p ?n))
    (not (lib ?n)))
;; (<= illegal
;; 	(not captured)
;; 	(notcontrol ?p)
;; 	(true (cell ?l ?c ?p ?n))
;; 	(not (lib ?n)))
(<= illegal
        (not captured)
        (true (step ?n))
        (++ ?n-1 ?n)
        (not (lib ?n-1)))

(<= (goal ?p 100) (true (control ?p)) illegal)
(<= (goal ?p 0) (true (control ?p)) captured)
(<= (goal ?p 0) (notcontrol ?p) illegal)
(<= (goal ?p 100) (notcontrol ?p) captured)

;; goban topology
(index 1) (index 2) (index 3) (index 4) (index 5)
 (index 6) (index 7)
;; (index  8) (index  9)
;; (index 10) (index 11)
;; (index 12) (index 13)
;; (index 14) (index 15)
;; (index 16) (index 17)
;; (index 18) (index 19)

(<= (ok ?l ?c) (index ?l) (index ?c))
(<= (+-1 ?a ?b) (++ ?a ?b))
(<= (+-1 ?a ?b) (++ ?b ?a))
(<= (neighbour ?l1 ?c ?l2 ?c) (ok ?l1 ?c) (+-1 ?l1 ?l2) (ok ?l2 ?c))
(<= (neighbour ?l ?c1 ?l ?c2) (ok ?l ?c1) (+-1 ?c1 ?c2) (ok ?l ?c2))

(<= (occupied ?l ?c) (true (cell ?l ?c ?x ?y)))
(<= (empty ?l ?c) (ok ?l ?c) (not (occupied ?l ?c)))

;; legal moves: any empty cell for the player in control
(<= (legal ?p noop) (notcontrol ?p))
(<= (legal ?p (mark ?l ?c)) (true (control ?p)) (empty ?l ?c))

;; needs N^2 integers for a NxN goban.
; awk 'BEGIN { for(i = 0; i < 182; i++) print "(++", i, i+1 ")" }'
(++ 0 1)
(++ 1 2)
(++ 2 3)
(++ 3 4)
(++ 4 5)
(++ 5 6)
(++ 6 7)
(++ 7 8)
(++ 8 9)
(++ 9 10)
(++ 10 11)
(++ 11 12)
(++ 12 13)
(++ 13 14)
(++ 14 15)
(++ 15 16)
(++ 16 17)
(++ 17 18)
(++ 18 19)
(++ 19 20)
(++ 20 21)
(++ 21 22)
(++ 22 23)
(++ 23 24)
(++ 24 25)
(++ 25 26)
(++ 26 27)
(++ 27 28)
(++ 28 29)
(++ 29 30)
(++ 30 31)
(++ 31 32)
(++ 32 33)
(++ 33 34)
(++ 34 35)
(++ 35 36)
(++ 36 37)
(++ 37 38)
(++ 38 39)
(++ 39 40)
(++ 40 41)
(++ 41 42)
(++ 42 43)
(++ 43 44)
(++ 44 45)
(++ 45 46)
(++ 46 47)
(++ 47 48)
(++ 48 49)
(++ 49 50)
(++ 50 51)
(++ 51 52)
(++ 52 53)
(++ 53 54)
(++ 54 55)
(++ 55 56)
(++ 56 57)
(++ 57 58)
(++ 58 59)
(++ 59 60)
(++ 60 61)
(++ 61 62)
(++ 62 63)
(++ 63 64)
(++ 64 65)
(++ 65 66)
(++ 66 67)
(++ 67 68)
(++ 68 69)
(++ 69 70)
(++ 70 71)
(++ 71 72)
(++ 72 73)
(++ 73 74)
(++ 74 75)
(++ 75 76)
(++ 76 77)
(++ 77 78)
(++ 78 79)
(++ 79 80)
(++ 80 81)
(++ 81 82)
(++ 82 83)
(++ 83 84)
(++ 84 85)
(++ 85 86)
(++ 86 87)
(++ 87 88)
(++ 88 89)
(++ 89 90)
(++ 90 91)
(++ 91 92)
(++ 92 93)
(++ 93 94)
(++ 94 95)
(++ 95 96)
(++ 96 97)
(++ 97 98)
(++ 98 99)
(++ 99 100)
(++ 100 101)
(++ 101 102)
(++ 102 103)
(++ 103 104)
(++ 104 105)
(++ 105 106)
(++ 106 107)
(++ 107 108)
(++ 108 109)
(++ 109 110)
(++ 110 111)
(++ 111 112)
(++ 112 113)
(++ 113 114)
(++ 114 115)
(++ 115 116)
(++ 116 117)
(++ 117 118)
(++ 118 119)
(++ 119 120)
(++ 120 121)
(++ 121 122)
(++ 122 123)
(++ 123 124)
(++ 124 125)
(++ 125 126)
(++ 126 127)
(++ 127 128)
(++ 128 129)
(++ 129 130)
(++ 130 131)
(++ 131 132)
(++ 132 133)
(++ 133 134)
(++ 134 135)
(++ 135 136)
(++ 136 137)
(++ 137 138)
(++ 138 139)
(++ 139 140)
(++ 140 141)
(++ 141 142)
(++ 142 143)
(++ 143 144)
(++ 144 145)
(++ 145 146)
(++ 146 147)
(++ 147 148)
(++ 148 149)
(++ 149 150)
(++ 150 151)
(++ 151 152)
(++ 152 153)
(++ 153 154)
(++ 154 155)
(++ 155 156)
(++ 156 157)
(++ 157 158)
(++ 158 159)
(++ 159 160)
(++ 160 161)
(++ 161 162)
(++ 162 163)
(++ 163 164)
(++ 164 165)
(++ 165 166)
(++ 166 167)
(++ 167 168)
(++ 168 169)
(++ 169 170)
(++ 170 171)
(++ 171 172)
(++ 172 173)
(++ 173 174)
(++ 174 175)
(++ 175 176)
(++ 176 177)
(++ 177 178)
(++ 178 179)
(++ 179 180)
(++ 180 181)
(++ 181 182)

;; input & base
(<= (input ?p (mark ?l ?c)) (role ?p) (ok ?l ?c))
(<= (input ?p noop) (role ?p))
(<= (base (control ?p)) (role ?p))
(<= (base (step ?x)) (++ ?x ?x+1))
(<= (base (cell ?l ?c ?p ?x)) (ok ?l ?c) (role ?p) (++ ?x ?x+1))
